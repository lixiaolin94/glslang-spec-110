# 概述

OpenGL 着色语言实际上是两种密切相关的语言。这些语言用于为 OpenGL 处理流水线中包含的可编程处理器创建着色器。这些可编程单元的精确定义留给单独的规范。在本文档中，我们只定义它们，足以为定义这些语言提供上下文。

除非本文中另有说明，语言特性适用于所有语言，通常的用法将把这些语言称为单一语言。具体的语言将以它们所针对的处理器的名称来称呼:顶点或片段。

## 顶点处理器

*顶点处理器*是一个可编程单元，它对传入的顶点值及其相关数据进行操作。顶点处理器旨在执行传统的图形操作，例如:

- 顶点变换(模型视图和投影矩阵)
- 法线变换和归一化
- 纹理坐标生成
- 纹理坐标变换
- 光照
- 颜色材质应用

用 OpenGL 着色语言编写的、打算在该处理器上运行的程序称为*顶点着色器*。顶点着色器可用于指定要应用于每个顶点及其相关数据的完全通用的操作序列。执行上述列表中某些计算的顶点着色器负责编写上述列表中所有所需功能的代码。例如，不可能使用现有的固定功能来执行顶点和法线变换，而让顶点着色器执行专门的光照功能。必须编写顶点着色器来执行所有三个功能。

顶点处理器不能替代需要同时了解多个顶点或需要拓扑知识的图形操作，例如:

- 透视除法
- 视口映射
- 图元组装
- 视锥和用户裁剪
- 背面剔除
- 双面光照选择
- 多边形模式处理
- 多边形偏移
- 深度范围

着色器使用的任何 OpenGL 状态都会自动被跟踪并提供给着色器使用。这种自动状态跟踪机制允许应用程序使用现有的 OpenGL 状态命令进行状态管理，并让当前状态值自动可用于顶点着色器中使用。

顶点处理器一次对一个顶点进行操作。顶点处理器的设计集中在变换和光照单个顶点所需的功能上。顶点着色器必须计算坐标的齐次位置，它们还可以计算颜色、纹理坐标和其他任意值，以传递给片段处理器。顶点处理器的输出通过后续的处理阶段发送，这些阶段的定义与 OpenGL 1.4 完全相同:图元组装、用户裁剪、视锥裁剪、透视投影、视口映射、多边形偏移、多边形模式、阴影模式和剔除。这个可编程单元没有从帧缓冲区读取的能力。但是，它确实具有纹理查找能力。细节级别不是由实现为顶点着色器计算的，但可以在着色器中指定。纹理贴图的 OpenGL 参数定义了过滤操作、边框和包装的行为。

## 片段处理器

*片段处理器*是一个可编程单元，用于操作片段值及其相关数据。片段处理器旨在执行传统的图形操作，例如：

- 对插值后的值进行操作
- 纹理访问
- 纹理应用
- 雾效
- 颜色求和

使用 OpenGL 着色语言编写的程序，如果打算在该处理器上运行，则称为*片段着色器*。片段着色器可用于指定要应用于每个片段的完全通用的操作序列。执行上述列表中某些计算的片段着色器必须执行上述列表中所有所需的功能。例如，不可能使用现有的固定功能来计算雾效，而让片段着色器执行专门的纹理访问和纹理应用。必须编写片段着色器来执行所有三个功能。

片段处理器不会替代发生在 OpenGL 像素处理管线后端的固定功能图形操作，例如：

- 着色模型
- 覆盖
- 像素所有权测试
- 裁剪
- 点画
- Alpha 测试
- 深度测试
- 模板测试
- Alpha 混合
- 逻辑操作
- 抖动
- 平面遮罩

如果着色器使用相关的 OpenGL 状态，也会自动跟踪它。片段着色器无法更改片段的 x/y 位置。为了支持片段处理级别的并行性，片段着色器的编写方式是表达单个片段所需的计算，并且不允许访问相邻片段。片段着色器可以自由地从单个纹理读取多个值，或从多个纹理读取多个值。片段着色器计算出的值最终用于更新帧缓冲内存或纹理内存，具体取决于当前的 OpenGL 状态以及导致生成这些片段的 OpenGL 命令。

纹理映射的 OpenGL 参数继续定义过滤操作、边框和包裹的行为。这些操作在访问纹理时应用。片段着色器可以自由地使用结果纹素。片段着色器可以从纹理中读取多个值并执行自定义过滤操作。也可以使用纹理执行查找表操作。在这两种情况下，纹理都应将其纹理参数设置为在纹理访问操作上应用最近邻过滤。

对于每个片段，片段着色器可以计算颜色和/或深度，或完全丢弃该片段。

然后，将片段着色器的结果发送出去进行进一步处理。OpenGL 管线的其余部分保持与 OpenGL 1.4 中定义的一致。在最终写入帧缓冲之前，片段将依次经过覆盖应用、像素所有权测试、裁剪测试、Alpha 测试、模板测试、深度测试、混合、抖动、逻辑操作和遮罩。将固定功能保留在处理管线的后端的主要原因是固定功能便宜且易于在硬件中实现。使这些功能可编程更加复杂，因为读/修改/写操作会引入显著的指令调度问题和管线停顿。

如果需要，可以禁用大多数这些固定功能操作，并在片段着色器中执行替代操作。
