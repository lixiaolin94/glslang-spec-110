# Built-In Functions

The OpenGL Shading Language defines an assortment of built-in convenience functions for scalar and vector operations. Many of these built-in functions can be used in more than one type of shader, but some are intended to provide a direct mapping to hardware and so are available only for a specific type of shader.

The built-in functions basically fall into three categories:

- They expose some necessary hardware functionality in a convenient way such as accessing a texture map. There is no way in the language for these functions to be emulated by a shader.
- They represent a trivial operation (clamp, mix, etc.) that is very simple for the user to write, but they are very common and may have direct hardware support. It is a very hard problem for the compiler to map expressions to complex assembler instructions.
- They represent an operation graphics hardware is likely to accelerate at some point. The trigonometry functions fall into this category.

Many of the functions are similar to the same named ones in common C libraries, but they support vector input as well as the more traditional scalar input.

Applications should be encouraged to use the built-in functions rather than do the equivalent computations in their own shader code since the built-in functions are assumed to be optimal (e.g., perhaps supported directly in hardware).

User code can replace built-in functions with their own if they choose, by simply re-declaring and defining the same name and argument list.

When the built-in functions are specified below, where the input arguments (and corresponding output) can be `float`, `vec2`, `vec3`, or `vec4`, `genType` is used as the argument. For any specific use of a function, the actual type has to be the same for all arguments and for the return type. Similarly for `mat`, which can be a `mat2`, `mat3`, or `mat4`.

## Angleand Trigonometry Functions

Function parameters specified as *angle* are assumed to be in units of radians. In no case will any of these functions result in a divide by zero error. If the divisor of a ratio is 0, then results will be undefined.

These all operate component-wise. The description is per component.

| Syntax                              | Description                                                                                                                                                                                                                          |
| ----------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| genType radians (genType degrees)   | Converts degrees to radians and returns the result, i.e., result = π/180 ⋅ degrees.                                                                                                                                                  |
| genType degrees (genType radians)   | Converts radians to degrees and returns the result, i.e., result = 180/π ⋅ radians.                                                                                                                                                  |
| genType sin (genType angle)         | The standard trigonometric sine function.                                                                                                                                                                                            |
| genType cos (genType angle)         | The standard trigonometric cosine function.                                                                                                                                                                                          |
| genType tan (genType angle)         | The standard trigonometric tangent.                                                                                                                                                                                                  |
| genType asin (genType x)            | Arc sine. Returns an angle whose sine is x. The range of values returned by this function is [–π/2, π/2]. Results are undefined if \|x\| > 1.                                                                                        |
| genType acos (genType x)            | Arc cosine. Returns an angle whose cosine is x. The range of values returned by this function is [0, π]. Results are undefined if \|x\| > 1.                                                                                         |
| genType atan (genType y, genType x) | Arc tangent. Returns an angle whose tangent is y/x. The signs of x and y are used to determine what quadrant the angle is in. The range of values returned by this function is [–π, π]. Results are undefined if x and y are both 0. |
| genType atan (genType y_over_x)     | Arc tangent. Returns an angle whose tangent is y_over_x. The range of values returned by this function is [–π/2, π/2].                                                                                                               |

## Exponential Functions

These all operate component-wise. The description is per component.

| Syntax                             | Description                                                                                                                                  |
| ---------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- |
| genType pow (genType x, genType y) | y Returns x raised to the y power, i.e., x .<br /><br />Results are undefined if x < 0. <br />Results are undefined if x = 0 and y <= 0.           |
| genType exp (genType x)            | x Returns the natural exponentiation of x, i.e., e .                                                                                         |
| genType log (genType x)            | Returns the natural logarithm of x, i.e., returns y<br /><br />the value y which satisfies the equation x = e . Results are undefined if x <= 0. |
| genType exp2 (genType x)           | x Returns 2 raised to the x power, i.e., 2 .                                                                                                 |
| genType log2 (genType x)           | Returns the base 2 logarithm of x, i.e., returns the y<br /><br />value y which satisfies the equation x = 2 . Results are undefined if x <= 0.  |
| genType sqrt (genType x)           | Returns the positive square root of x. Results are undefined if x < 0.                                                                       |
| genType inversesqrt (genType x)    | Returns the reciprocal of the positive square root of x.<br /><br />Results are undefined if x <= 0.                                             |

## Common Functions

These all operate component-wise. The description is per component.

| Syntax                                                                                                                   | Description                                                                                                                                                                                                                                                                                                                                               |
| ------------------------------------------------------------------------------------------------------------------------ | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| genType abs (genType x)                                                                                                  | Returns x if x >= 0, otherwise it returns –x                                                                                                                                                                                                                                                                                                              |
| genType sign (genType x)                                                                                                 | Returns 1.0 if x > 0, 0.0 if x = 0, or –1.0 if x < 0                                                                                                                                                                                                                                                                                                      |
| genType floor (genType x)                                                                                                | Returns a value equal to the nearest integer that is less than or equal to x                                                                                                                                                                                                                                                                              |
| genType ceil (genType x)                                                                                                 | Returns a value equal to the nearest integer that is greater than or equal to x                                                                                                                                                                                                                                                                           |
| genType fract (genType x)                                                                                                | Returns x – floor (x)                                                                                                                                                                                                                                                                                                                                     |
| genType mod (genType x, genType y)<br />genType mod (genType x, float y)                                                   | Modulus. Returns x – y \* floor (x/y)                                                                                                                                                                                                                                                                                                                      |
| genType min (genType x, genType y)<br />genType min (genType x, float y)                                                   | Returns y if y < x, otherwise it returns x                                                                                                                                                                                                                                                                                                                |
| genType max (genType x, genType y)<br />genType max (genType x, float y)                                                   | Returns y if x < y, otherwise it returns x                                                                                                                                                                                                                                                                                                                |
| genType clamp (genType x, genType minVal, genType maxVal)<br />genType clamp (genType x, float minVal, float maxVal)       | Returns min (max (x, minVal), maxVal) <br />Note that colors and depths written by fragment shaders will be clamped by the implementation after the fragment shader runs.                                                                                                                                                                                   |
| genType mix (genType x, genType y, genType a) <br />genType mix (genType x, genType y, float a)                            | Returns x \* (1 – a) + y \* a, i.e., the linear blend of x and y                                                                                                                                                                                                                                                                                            |
| genType step (genType edge, genType x)<br />genType step (float edge, genType x)                                           | Returns 0.0 if x < edge, otherwise it returns 1.0                                                                                                                                                                                                                                                                                                         |
| genType smoothstep (genType edge0, genType edge1, genType x)<br />genType smoothstep (float edge0, float edge1, genType x) | Returns 0.0 if x <= edge0 and 1.0 if x >= edge1 and performs smooth Hermite interpolation between 0 and 1 when edge0 < x < edge1. This is useful in cases where you would want a threshold function with a smooth transition. This is equivalent to:<br /> genType t;<br /> t = clamp ((x – edge0) / (edge1 – edge0), 0, 1);<br /> return t \* t \* (3 – 2 \* t); |

## Geometric Functions

These operate on vectors as vectors, not component-wise.

| Syntax                                                   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                  |
| -------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| float length (genType x)                                 | Returns the length of vector x, i.e.,<br /><br />sqrt (x[0] \* x[0] + x[1] \* x[1] + ...)                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| float distance (genType p0, genType p1)                  | Returns the distance between p0 and p1, i.e.,<br /><br />length (p0 – p1)                                                                                                                                                                                                                                                                                                                                                                                                                                                                        |
| float dot (genType x, genType y)                         | Returns the dot product of x and y, i.e.,<br /><br />result = x[0] \* y[0] + x[1] \* y[1] + ...                                                                                                                                                                                                                                                                                                                                                                                                                                                    |
| vec3 cross (vec3 x, vec3 y)                              | Returns the cross product of x and y, i.e.,<br /><br />result.0 = x[1] \* y[2] - y[1] \* x[2] <br />result.1 = x[2] \* y[0] - y[2] \* x[0] <br />result.2 = x[0] \* y[1] - y[0] \* x[1]                                                                                                                                                                                                                                                                                                                                                                    |
| genType normalize (genType x)                            | Returns a vector in the same direction as x but with a length of 1.                                                                                                                                                                                                                                                                                                                                                                                                                                                                          |
| vec4 ftransform()                                        | For vertex shaders only. This function will ensure that the incoming vertex value will be transformed in a way that produces exactly the same result as would be produced by OpenGL’s fixed functionality transform. It is intended to be used to compute gl_Position, e.g.,<br /><br />gl_Position = ftransform()<br /><br />This function should be used, for example, when an application is rendering the same geometry in separate passes, and one pass uses the fixed functionality path to render and another pass uses programmable shaders. |
| genType faceforward (genType N, genType I, genType Nref) | If dot (Nref, I) < 0 return N otherwise return –N                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| genType reflect (genType I, genType N)                   | For the incident vector I and surface orientation N, returns the reflection direction:<br /><br />result = I – 2 \* dot(N, I) \* N<br /><br />N must already be normalized in order to achieve the desired result.                                                                                                                                                                                                                                                                                                                                     |
| genType refract(genType I, genType N, float eta)         | For the incident vector I and surface normal N, and the ratio of indices of refraction eta, return the refraction vector. The returned result is computed by<br /><br />k = 1.0 - eta \* eta \* (1.0 - dot(N, I) \* dot(N, I)) <br />if (k < 0.0)<br /> result = genType(0.0)<br />else<br /> result = eta \* I - (eta \* dot(N, I) + sqrt(k)) \* N<br /><br />The input parameters for the incident vector I and the surface normal N must already be normalized to get the desired results.                                                                      |

## Matrix Functions

| Syntax                            | Description                                                                                                                                                                                                |
| --------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| mat matrixCompMult (mat x, mat y) | Multiply matrix x by matrix y component-wise, i.e., result\[i\]\[j\] is the scalar product of x\[i\]\[j\] and y\[i\]\[j\].<br /><br />Note: to get linear algebraic matrix multiplication, use the multiply operator (`*`). |

## Vector Relational Functions

Relational and equality operators (`<`, `<=`, `>`, `>=`, `==`, `!=`) are defined (or reserved) to produce scalar Boolean results. For vector results, use the following built-in functions. Below, "bvec" is a placeholder for one of `bvec2`, `bvec3`, or `bvec4`, "ivec" is a placeholder for one of `ivec2`, `ivec3`, or `ivec4`, and "vec" is a placeholder for `vec2`, `vec3`, or `vec4`. In all cases, the sizes of the input and return vectors for any particular call must match.

| Syntax                                                                                          | Description                                         |
| ----------------------------------------------------------------------------------------------- | --------------------------------------------------- |
| bvec lessThan(vec x, vec y) <br />bvec lessThan(ivec x, ivec y)                                   | Returns the component-wise compare of x < y.        |
| bvec lessThanEqual(vec x, vec y) <br />bvec lessThanEqual(ivec x, ivec y)                         | Returns the component-wise compare of x <= y.       |
| bvec greaterThan(vec x, vec y) <br />bvec greaterThan(ivec x, ivec y)                             | Returns the component-wise compare of x > y.        |
| bvec greaterThanEqual(vec x, vec y) <br />bvec greaterThanEqual(ivec x, ivec y)                   | Returns the component-wise compare of x >= y.       |
| bvec equal(vec x, vec y) <br />bvec equal(ivec x, ivec y) <br />bvec equal(bvec x, bvec y)          | Returns the component-wise compare of x == y.       |
| bvec notEqual(vec x, vec y) <br />bvec notEqual(ivec x, ivec y) <br />bvec notEqual(bvec x, bvec y) | Returns the component-wise compare of x != y.       |
| bool any(bvec x)                                                                                | Returns true if any component of x is true.         |
| bool all(bvec x)                                                                                | Returns true only if all components of x are true.  |
| bvec not(bvec x)                                                                                | Returns the component-wise logical complement of x. |

## Texture Lookup Functions

Texture lookup functions are available to both vertex and fragment shaders. However, level of detail is not computed by fixed functionality for vertex shaders, so there are some differences in operation between vertex and fragment texture lookups. The functions in the table below provide access to textures through samplers, as set up through the OpenGL API. Texture properties such as size, pixel format, number of dimensions, filtering method, number of mip-map levels, depth comparison, and so on are also defined by OpenGL API calls. Such properties are taken into account as the texture is accessed via the built-in functions defined below.

If a non-shadow texture call is made to a sampler that represents a depth texture with depth comparisons turned on, then results are undefined. If a shadow texture call is made to a sampler that represents a depth texture with depth comparisons turned off, then results are undefined. If a shadow texture call is made to a sampler that does not represent a depth texture, then results are undefined.

In all functions below, the bias parameter is optional for fragment shaders. The bias parameter is not accepted in a vertex shader. For a fragment shader, if bias is present, it is added to the calculated level of detail prior to performing the texture access operation. If the bias parameter is not provided, then the implementation automatically selects level of detail: For a texture that is not mip-mapped, the texture is used directly. If it is mip-mapped and running in a fragment shader, the LOD computed by the implementation is used to do the texture lookup. If it is mip-mapped and running on the vertex shader, then the base texture is used.

The built-ins suffixed with "**Lod**" are allowed only in a vertex shader. For the "**Lod**" functions, lod is directly used as the level of detail.

| Syntax                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                   | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                               |
| -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| vec4 texture1D (sampler1D sampler, float coord [, float bias] )<br /><br />vec4 texture1DProj (sampler1D sampler, vec2 coord [, float bias] )<br /><br />vec4 texture1DProj (sampler1D sampler, vec4 coord [, float bias] )<br /><br />vec4 texture1DLod (sampler1D sampler, float coord, float lod)<br /><br />vec4 texture1DProjLod (sampler1D sampler, vec2 coord, float lod)<br /><br />vec4 texture1DProjLod (sampler1D sampler, vec4 coord, float lod)                                                                                                                                                                 | Use the texture coordinate coord to do a texture lookup in the 1D texture currently bound to sampler. For the projective ("Proj") versions, the texture coordinate coord.s is divided by the last component of coord.                                                                                                                                                                                                                                                                                                                     |
| vec4 texture2D (sampler2D sampler, vec2 coord [, float bias] )<br /><br />vec4 texture2DProj (sampler2D sampler, vec3 coord [, float bias] )<br /><br />vec4 texture2DProj (sampler2D sampler, vec4 coord [, float bias] )<br /><br />vec4 texture2DLod (sampler2D sampler, vec2 coord, float lod)<br /><br />vec4 texture2DProjLod (sampler2D sampler, vec3 coord, float lod)<br /><br />vec4 texture2DProjLod (sampler2D sampler, vec4 coord, float lod)                                                                                                                                                                   | Use the texture coordinate coord to do a texture lookup in the 2D texture currently bound to sampler. For the projective ("Proj") versions, the texture coordinate (coord.s, coord.t) is divided by the last component of coord. The third component of coord is ignored for the vec4 coord variant.                                                                                                                                                                                                                                      |
| vec4 texture3D (sampler3D sampler, vec3 coord [, float bias] )<br /><br />vec4 texture3DProj (sampler3D sampler, vec4 coord [, float bias] )<br /><br />vec4 texture3DLod (sampler3D sampler, vec3 coord, float lod)<br /><br />vec4 texture3DProjLod (sampler3D sampler, vec4 coord, float lod)                                                                                                                                                                                                                                                                                                                     | Use the texture coordinate coord to do a texture lookup in the 3D texture currently bound to sampler. For the projective ("Proj") versions, the texture coordinate is divided by coord.q.                                                                                                                                                                                                                                                                                                                                                 |
| vec4 textureCube (samplerCube sampler, vec3 coord [, float bias] )<br /><br />vec4 textureCubeLod (samplerCube sampler, vec3 coord, float lod)                                                                                                                                                                                                                                                                                                                                                                                                                                                               | Use the texture coordinate coord to do a texture lookup in the cube map texture currently bound to sampler. The direction of coord is used to select which face to do a 2-dimensional texture lookup in, as described in section 3.8.6 in version 1.4 of the OpenGL specification.                                                                                                                                                                                                                                                        |
| vec4 shadow1D (sampler1DShadow sampler, vec3 coord [, float bias] )<br /><br />vec4 shadow2D (sampler2DShadow sampler, vec3 coord [, float bias] ) vec4 shadow1DProj (sampler1DShadow sampler,<br /><br />vec4 coord [, float bias] ) vec4 shadow2DProj (sampler2DShadow sampler,<br /><br />vec4 coord [, float bias] ) vec4 shadow1DLod (sampler1DShadow sampler,<br /><br />vec3 coord, float lod) vec4 shadow2DLod (sampler2DShadow sampler,<br /><br />vec3 coord, float lod) vec4 shadow1DProjLod(sampler1DShadow sampler, vec4 coord, float lod) vec4 shadow2DProjLod(sampler2DShadow sampler, vec4 coord, float lod) | Use texture coordinate coord to do a depth comparison lookup on the depth texture bound to sampler, as described in section 3.8.14 of version 1.4 of the OpenGL specification. The 3rd component of coord (coord.p) is used as the R value. The texture bound to sampler must be a depth texture, or results are undefined. For the projective ("Proj") version of each built-in, the texture coordinate is divide by coord.q, giving a depth value R of coord.p/coord.q. The second component of coord is ignored for the "1D" variants. |

## Fragment Processing Functions

Fragment processing functions are only available in shaders intended for use on the fragment processor.

Derivatives may be computationally expensive and/or numerically unstable. Therefore, an OpenGL

implementation may approximate the true derivatives by using a fast but not entirely accurate derivative computation.

The expected behavior of a derivative is specified using forward/backward differencing.

Forward differencing:

``` glsl
F(x+dx) - F(x) ~ dFdx(x) * dx     1a
dFdx(x) ~ (F(x+dx) - F(x)) / dx   1b
```

Backward differencing:

``` glsl
F(x-dx) - F(x) ~ -dFdx(x) * dx    2a
dFdx(x) ~ (F(x) - F(x-dx)) / dx   2b
```

With single-sample rasterization, dx <= 1.0 in equations 1b and 2b. For multi-sample rasterization, dx < 2.0 in equations 1b and 2b.

`dFdy` is approximated similarly, with y replacing x.

A GL implementation may use the above or other methods to perform the calculation, subject to the following conditions:

1. The method may use piecewise linear approximations. Such linear approximations imply that higher order derivatives, `dFdx(dFdx(x))` and above, are undefined.

2. The method may assume that the function evaluated is continuous. Therefore derivatives within the body of a non-uniform conditional are undefined.

3. The method may differ per fragment, subject to the constraint that the method may vary by window coordinates, not screen coordinates. The invariance requirement described in section 3.1 of the OpenGL 1.4 specification is relaxed for derivative calculations, because the method may be a function of fragment location.

Other properties that are desirable, but not required, are:

4. Functions should be evaluated within the interior of a primitive (interpolated, not extrapolated).

5. Functions for `dFdx` should be evaluated while holding y constant. Functions for `dFdy` should be evaluated while holding x constant. However, mixed higher order derivatives, like `dFdx(dFdy(y))` and `dFdy(dFdx(x))` are undefined.

In some implementations, varying degrees of derivative accuracy may be obtained by providing GL hints (section 5.6 of the OpenGL 1.4 specification), allowing a user to make an image quality versus speed tradeoff.

| Syntax                     | Description                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            |
| -------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ |
| genType dFdx (genType p)   | Returns the derivative in x using local differencing for the input argument p.                                                                                                                                                                                                                                                                                                                                                                                                                         |
| genType dFdy (genType p)   | Returns the derivative in y using local differencing for the input argument p.<br />These two functions are commonly used to estimate the filter width used to anti-alias procedural textures.We are assuming that the expression is being evaluated in parallel on a SIMD array so that at any given point in time the value of the function is known at the grid points represented by the SIMD array. Local differencing between SIMD array elements can therefore be used to derive dFdx, dFdy, etc. |
| genType fwidth (genType p) | Returns the sum of the absolute derivative in x and y using local differencing for the input argument p, i.e.,<br /><br />return = abs (dFdx (p)) + abs (dFdy (p));                                                                                                                                                                                                                                                                                                                                        |

## Noise Functions

Noise functions are available to both fragment and vertex shaders. They are stochastic functions that can be used to increase visual complexity. Values returned by the following noise functions give the appearance of randomness, but are not truly random. The noise functions below are defined to have the following characteristics:

- The return value(s) are always in the range [-1.0,1.0], and cover at least the range [-0.6, 0.6], with a gaussian-like distribution.
- The return value(s) have an overall average of 0.0
- They are repeatable, in that a particular input value will always produce the same return value
- They are statistically invariant under rotation (i.e., no matter how the domain is rotated, it has the same statistical character)
- They have a statistical invariance under translation (i.e., no matter how the domain is translated, it has the same statistical character)
- They typically give different results under translation.
- The spatial frequency is narrowly concentrated, centered somewhere between 0.5 to 1.0.
- They are C<sup>1</sup> continuous everywhere (i.e., the first derivative is continuous)

| Syntax                   | Description                                          |
| ------------------------ | ---------------------------------------------------- |
| float noise1 (genType x) | Returns a 1D noise value based on the input value x. |
| vec2 noise2 (genType x)  | Returns a 2D noise value based on the input value x. |
| vec3 noise3 (genType x)  | Returns a 3D noise value based on the input value x. |
| vec4 noise4 (genType x)  | Returns a 4D noise value based on the input value x. |
