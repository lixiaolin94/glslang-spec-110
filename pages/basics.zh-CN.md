# 基础

## 字符集

用于 OpenGL 着色语言的源字符集是 ASCII 的子集。它包括以下字符：

- 字母 **a-z**、**A-Z** 和下划线（`_`）。
- 数字 **0-9**。
- 符号句点（`.`）、加号（`+`）、破折号（`-`）、斜杠（`/`）、星号（`*`）、百分号（`%`）。
- 符号尖括号（`<` 和 `>`）、方括号（`[` 和 `]`）、圆括号（`(` 和 `)`）、大括号（`{` 和 `}`）。
- 符号插入符号（`^`）、竖线（`|`）、和号（`&`）、波浪号（`~`）、等号（`=`）、感叹号（`!`）。
- 符号冒号（`:`）、分号（`;`）、逗号（`,`）和问号（`?`）。
- 用于预处理器的井号（`#`）。
- 空白字符：空格字符、水平制表符、垂直制表符、换页符、回车符和换行符。

行对编译器诊断消息和预处理器很重要。它们由回车符或换行符终止。如果两者一起使用，它将只算作一个行终止符。在本文档的其余部分，这些组合简称为换行符。

通常，语言对该字符集的使用是区分大小写的。

没有字符或字符串数据类型，因此不包括引号字符。

没有文件结束字符。源字符串的结尾由长度指示，而不是字符。

## 源字符串

单个着色器的源代码是来自字符集的字符串数组。单个着色器是由这些字符串连接而成的。每个字符串可以包含多行，由换行符分隔。字符串中不需要出现换行符；单行可以由多个字符串组成。实现在连接字符串以形成单个着色器时，不会插入换行符或其他字符。可以将相同语言（顶点或片段）的多个着色器链接在一起，形成单个程序。

编译着色器返回的诊断消息必须标识字符串中的行号以及消息适用的源字符串。源字符串按顺序计数，第一个字符串为字符串 0。行号比已处理的换行符数多 1。

## 预处理器

有一个预处理器在编译源字符串之前对其进行处理。

预处理器指令的完整列表如下。

``` glsl
#
#define
#undef

#if
#ifdef
#ifndef
#else
#elif
#endif

#error
#pragma

#extension
#version

#line
```

The following operators are also available

``` glsl
defined
```

每个井号（`#`）在其所在行只能以空格或水平制表符为前导。它后面也可以跟空格和水平制表符，位于指令之前。每个指令都以换行符终止。预处理不会改变源字符串中换行符的数量或相对位置。

单独一行的井号（`#`）将被忽略。上述未列出的任何指令都将导致诊断消息，并使实现将着色器视为格式不正确。

`#define` 和 `#undef` 功能的定义与 C++ 预处理器的标准宏定义（包括带有和不带宏参数）相同。

以下预定义宏可用：

``` glsl
__LINE__
__FILE__
__VERSION__
```

\_\_LINE\_\_ 将替换为一个十进制整数常量，该常量比当前源字符串中前面的换行符数多 1。

\_\_FILE\_\_ 将替换为一个十进制整数常量，表示当前正在处理的源字符串编号。

\_\_VERSION\_\_ 将替换为一个十进制整数，反映 OpenGL 着色语言的版本号。本文档中描述的着色语言版本的 \_\_VERSION\_\_ 将替换为十进制整数 110。

所有包含两个连续下划线（`__`）的宏名称均保留供未来用作预定义的宏名称。所有以 "GL\_"（"GL" 后跟一个下划线）为前缀的宏名称也是保留的。

`#if`、`#ifdef`、`#ifndef`、`#else`、`#elif` 和 `#endif` 的定义与 C++ 预处理器的标准定义相同。

`#if` 和 `#elif` 之后的表达式仅限于对字面整数常量进行操作的表达式，以及由 `defined` 运算符使用的标识符。不支持字符常量。可用的运算符有：

| 优先级    | 运算符类别 | 运算符       | 结合性   |
| --------- | ---------- | ------------ | -------- |
| 1（最高） | 括号分组   | ()           | 不适用   |
| 2         | 一元       | defined +-~! | 从右到左 |
| 3         | 乘法       | \*/%         | 从左到右 |
| 4         | 加法       | +-           | 从左到右 |
| 5         | 位移       | << >>        | 从左到右 |
| 6         | 关系       | < > <= >=    | 从左到右 |
| 7         | 相等       | == !=        | 从左到右 |
| 8         | 按位与     | &            | 从左到右 |
| 9         | 按位异或   | ^            | 从左到右 |
| 10        | 按位或     | \|           | 从左到右 |
| 11        | 逻辑与     | &&           | 从左到右 |
| 12        | 逻辑或     | \|\|         | 从左到右 |

`defined` 运算符可以通过以下两种方式之一使用：

``` glsl
defined identifier
defined ( identifier )
```

没有基于井号的运算符（没有 `#`、`#@`、`##` 等），也没有 `sizeof` 运算符。

在预处理器中将运算符应用于整数字面量的语义与 C++ 预处理器中的标准语义相匹配，而不是与 OpenGL 着色语言中的语义相匹配。

预处理器表达式将根据主机处理器的行为进行求值，而不是根据着色器目标处理器的行为进行求值。

`#error` 将导致实现将诊断消息放入着色器的信息日志中（有关如何访问着色器的信息日志，请参阅外部文档中的 API）。消息将是 `#error` 指令后面的标记，直到第一个换行符。然后，实现必须将着色器视为格式不正确。

`#pragma` 允许实现相关的编译器控制。`#pragma` 后面的标记不受预处理器宏扩展的影响。如果实现无法识别 `#pragma` 后面的标记，则会忽略该 pragma。以下 pragma 被定义为语言的一部分。

``` glsl
#pragma STDGL
```

**STDGL** pragma 用于为将来修订本语言保留 pragma。任何实现都不得使用第一个标记为 **STDGL** 的 pragma。

``` glsl
#pragma optimize(on)
#pragma optimize(off)
```

可用于关闭优化，以帮助开发和调试着色器。它只能在函数定义之外使用。默认情况下，对所有着色器启用优化。调试 pragma

``` glsl
#pragma debug(on)
#pragma debug(off)
```

可用于启用编译和使用调试信息注释着色器，以便可以将其与调试器一起使用。它只能在函数定义之外使用。默认情况下，调试是关闭的。

着色器应声明它们编写的语言版本。着色器编写的语言版本由以下指定：

``` glsl
#version number
```

其中 number 对于本规范的语言版本必须为 110（遵循与上面的 \_\_VERSION\_\_ 相同的约定），在这种情况下，该指令将被接受，不会产生错误或警告。任何小于 110 的数字都会导致生成错误。任何大于编译器支持的最新语言版本的数字也会导致生成错误。语言的版本 110 不要求着色器包含此指令，不包含 `#version` 指令的着色器将被视为针对版本 110。本语言后续版本的编译器保证，在着色器中看到 `#version 110` 指令时，要么支持版本 110，要么发出不支持它的错误。

`#version` 指令必须在着色器中的任何其他内容之前出现，除了注释和空白。

默认情况下，本语言的编译器必须为不符合本规范的着色器发出编译时句法、语法和语义错误。任何扩展行为必须首先启用。

用于控制编译器行为的指令是关于扩展的，使用 `#extension` 指令声明：

``` glsl
#extension extension_name : behavior
#extension all : behavior
```

其中 extension_name 是扩展的名称。扩展名未在本规范中记录。标记 **all** 表示该行为适用于编译器支持的所有扩展。行为可以是以下之一：

| 行为    | 效果                                                                                                                                                                                                                                                            |
| ------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| require | 按扩展 extension_name 指定的方式运作。<br><br>如果不支持扩展 extension_name，或者指定了 **all**，则在 `#extension` 上给出错误。                                                                                                                                 |
| enable  | 按扩展 extension_name 指定的方式运作。<br><br>如果不支持扩展 extension_name，则在 `#extension` 上发出警告。<br><br>如果指定了 **all**，则在 `#extension` 上给出错误。                                                                                           |
| warn    | 按扩展 extension_name 指定的方式运作，但对于任何不受其他已启用或所需扩展支持的可检测到的该扩展的使用发出警告。<br><br>如果指定了 **all**，则对使用的任何扩展的所有可检测到的使用发出警告。<br><br>如果不支持扩展 extension_name，则在 `#extension` 上发出警告。 |
| disable | 表现（包括发出错误和警告）就好像扩展 extension_name 不是语言定义的一部分。<br><br>如果指定了 **all**，则行为必须恢复到正在编译的语言的非扩展核心版本的行为。<br><br>如果不支持扩展 extension_name，则在 `#extension` 上发出警告。                               |

**extension** 指令是一种简单的低级机制，用于设置每个扩展的行为。它没有定义诸如哪些组合是合适的等策略，这些必须在其他地方定义。指令的顺序对于设置每个扩展的行为很重要：后出现的指令会覆盖之前看到的指令。**all** 变体为所有扩展设置行为，覆盖所有先前发出的 **extension** 指令，但仅适用于 **warn** 和 **disable** *行为*。

编译器的初始状态就好像发出了以下指令：

``` glsl
#extension all : disable
```

告诉编译器所有错误和警告报告都必须按照本规范进行，忽略任何扩展。

每个扩展都可以定义其允许的作用域粒度。如果没有说明，则粒度为着色器（即单个编译单元），并且扩展指令必须出现在任何非预处理器标记之前。如果需要，链接器可以强制执行大于单个编译单元的粒度，在这种情况下，每个涉及的着色器都必须包含必要的扩展指令。

包含 `#extension` 和 `#version` 指令的行不会进行宏展开。

`#line` 在宏替换后必须具有以下两种形式之一：

``` glsl
#line line
#line line source-string-number
```

其中 *line*_* 和 *source-string-number* 是常量整数表达式。处理此指令（包括其新行）后，实现将表现得好像它正在编译行号 *line+1* 和源字符串编号 *source-string-number*。后续源字符串将按顺序编号，直到另一个 `#line` 指令覆盖该编号。

## 注释

注释由 \/\* 和 \*\/ 或由 \/\/ 和新行分隔。注释内部不会将开始注释分隔符（\/\* 或 \/\/）识别为注释分隔符，因此注释不能嵌套。如果注释完全位于单行内，则在语法上将其视为单个空格。

## 标记

语言是标记的序列。标记可以是：

``` glsl
token:
  keyword
  identifier
  integer-constant
  floating-constant
  operator
```

## 关键字

以下是语言中的关键字，除本文档定义的用途外，不能用于任何其他目的：

``` glsl
attribute const uniform varying

break continue do for while

if

else

in out inout

float int void bool true false

discard return

mat2 mat3 mat4

vec2 vec3 vec4

ivec2 ivec3 ivec4

bvec2 bvec3 bvec4

sampler1D sampler2D sampler3D samplerCube sampler1DShadow sampler2DShadow

struct
```

以下是为将来使用而保留的关键字。使用它们会导致错误：

``` glsl
asm

class union enum typedef template this packed

goto switch default

inline noinline volatile public static extern external interface

long short double half fixed unsigned

input output

hvec2 hvec3 hvec4 dvec2 dvec3 dvec4 fvec2 fvec3 fvec4

sampler2DRect sampler3DRect sampler2DRectShadow

sizeof cast

namespace using
```

此外，所有包含两个连续下划线（`__`）的标识符都保留为可能的未来关键字。

## 标识符

标识符用于变量名、函数名、结构体名和字段选择器（字段选择器选择向量和矩阵的分量，类似于结构体字段，如第 5.5 节“向量分量”和第 5.6 节“矩阵分量”中所述）。标识符具有以下形式：

``` glsl
identifier
  nondigit
  identifier nondigit
  identifier digit

nondigit: one of
  _ a b c d e f g h i j k l m n o p q r s t u v w x y z
  A B C D E F G H I J K L M N O P Q R S T U V W X Y Z

digit: one of
  0 1 2 3 4 5 6 7 8 9
```

以 "gl\_" 开头的标识符是 OpenGL 保留使用的，不能在着色器中声明为变量或函数。
