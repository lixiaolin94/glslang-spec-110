# 运算符和表达式

## 运算符

OpenGL 着色语言具有以下运算符。标记为保留的是非法的。

| 优先级      | 运算符类别                                                                  | 运算符                                         | 结合性   |
| ----------- | --------------------------------------------------------------------------- | ---------------------------------------------- | -------- |
| 1 (highest) | 括号分组                                                                    | ()                                             | NA       |
| 2           | 数组下标<br>函数调用和构造函数<br>结构体字段选择器、swizzler 后缀递增和递减 | [] <br>() <br>. <br>++ --                      | 从左到右 |
| 3           | 前缀递增和递减<br>一元（波浪号保留）                                        | ++ -- +-~!                                     | 从右到左 |
| 4           | 乘法（模保留）                                                              | \*/%                                           | 从左到右 |
| 5           | 加法                                                                        | +-                                             | 从左到右 |
| 6           | 按位移位（保留）                                                            | << >>                                          | 从左到右 |
| 7           | 关系                                                                        | < > <= >=                                      | 从左到右 |
| 8           | 相等                                                                        | == !=                                          | 从左到右 |
| 9           | 按位与（保留）                                                              | &                                              | 从左到右 |
| 10          | 按位异或（保留）                                                            | ^                                              | 从左到右 |
| 11          | 按位或（保留）                                                              | \|                                             | 从左到右 |
| 12          | 逻辑与                                                                      | &&                                             | 从左到右 |
| 13          | 逻辑异或                                                                    | ^^                                             | 从左到右 |
| 14          | 逻辑或                                                                      | \|                                             | 从左到右 |
| 15          | 选择                                                                        | ?:                                             | 从右到左 |
| 16          | 赋值<br>算术赋值<br>（模、移位和按位保留）                                  | = <br>+= -= <br>\*= /= %= <<= >>=<br>&= ^= \|= | 从右到左 |
| 17 (lowest) | 序列                                                                        | ,                                              | 从左到右 |

没有取地址运算符和解引用运算符。没有类型转换运算符，而是使用构造函数。

## 数组下标

使用数组下标运算符（[ ]）访问数组元素。这是唯一对数组进行操作的运算符。访问数组元素的一个示例是：

``` glsl
diffuseColor += lightIntensity[3] * NdotL;
```

数组索引从零开始。使用类型为整数的表达式访问数组元素。

如果着色器对数组使用小于 0 或大于等于声明数组大小的索引进行下标操作，行为是未定义的。

## 函数调用

如果函数返回值，则对该函数的调用可以用作表达式，其类型将是声明或定义函数时使用的类型。

函数定义和调用约定在第 6.1 节“函数定义”中讨论。

## 构造函数

构造函数使用函数调用语法，其中函数名是基本类型关键字或结构体名，以构造所需类型的值，用于初始化器或表达式中。（有关详细信息，请参见第 9 节“着色语言语法”。）参数用于初始化构造的值。构造函数可用于请求数据类型转换，以从一种标量类型更改为另一种标量类型，或从较小类型构建较大类型，或将较大类型缩减为较小类型。

没有固定的构造函数原型列表。构造函数不是内置函数。语法上，所有词法正确的参数列表都是有效的。语义上，参数的数量必须足够大并且类型正确，以执行初始化。在构造函数中包含太多参数而无法全部使用是错误的。详细规则如下。下面实际列出的原型只是示例的一个子集。

### 转换和标量构造函数

在标量类型之间进行转换的方式如下面的原型所示：

``` glsl
int(bool)     // 将布尔值转换为整数
int(float)    // 将浮点值转换为整数
float(bool)   // 将布尔值转换为浮点数
float(int)    // 将整数值转换为浮点数
bool(float)   // 将浮点值转换为布尔值
bool(int)     // 将整数值转换为布尔值
```

当使用构造函数将浮点数转换为整数时，浮点值的小数部分将被丢弃。

当使用构造函数将 `int` 或 `float` 转换为 `bool` 时，0 和 0.0 转换为 `false`，非零值转换为 `true`。当使用构造函数将 `bool` 转换为 `int` 或 `float` 时，`false` 转换为 0 或 0.0，`true` 转换为 1 或 1.0。

同一类型的构造函数，如 float(float) 也是合法的，但用处不大。

具有非标量参数的标量构造函数可用于从非标量中获取第一个元素。例如，构造函数 float(vec3) 将选择 vec3 参数的第一个分量。

### 向量和矩阵构造函数

构造函数可用于从一组标量、向量或矩阵创建向量或矩阵。这包括缩短向量的能力。

如果向量构造函数有单个标量参数，则用于将构造的向量的所有分量初始化为该标量的值。如果矩阵构造函数有单个标量参数，则用于将矩阵对角线上的所有分量初始化为该标量的值，其余分量初始化为 0.0。如果有非标量参数和/或多个标量参数，它们将按从左到右的顺序分配给构造值的分量。在这种情况下，必须在参数中提供足够的分量，以为构造值中的每个分量提供一个初始值。如果构造函数的最后一个使用的参数提供的分量多于初始化构造值所需的分量，则使用该参数最左边的分量，其余的将被忽略。在此最后使用的参数之后提供额外的参数是错误的。矩阵将以列主序构造。从其他矩阵构造矩阵是错误的。这是为将来使用而保留的。

如果构造函数的参数的基本类型（`bool`、`int` 或 `float`）与正在构造的对象的基本类型不匹配，则使用标量构造规则（上面）将参数转换。

一些有用的向量构造函数如下：

``` glsl
vec3(float)   // 用浮点数初始化 vec3 的每个分量
vec4(ivec4)   // 用 ivec4 构造 vec4，进行分量转换

vec2(float, float)              // 用 2 个浮点数初始化 vec2
ivec3(int, int, int)            // 用 3 个整数初始化 ivec3
bvec4(int, int, float, float)   // 用 4 个布尔转换初始化

vec2(vec3)    // 丢弃 vec3 的第三个分量
vec3(vec4)    // 丢弃 vec4 的第四个分量

vec3(vec2, float)   // vec3.x = vec2.x, vec3.y = vec2.y, vec3.z = float
vec3(float, vec2)   // vec3.x = float, vec3.y = vec2.x, vec3.z = vec2.y
vec4(vec3, float)
vec4(float, vec3)
vec4(vec2, vec2)
```

其中一些示例是：

``` glsl
vec4 color = vec4(0.0, 1.0, 0.0, 1.0);
vec4 rgba = vec4(1.0);    // 将每个分量设置为 1.0
vec3 rgb = vec3(color);   // 丢弃第 4 个分量
```

要将矩阵的对角线初始化为某个值，其他所有元素设置为零：

``` glsl
mat2(float)
mat3(float)
mat4(float)
```

要通过指定向量或所有 4、9 或 16 个浮点数（分别用于 mat2、mat3 和 mat4）来初始化矩阵。浮点数按列主序分配给元素。

``` glsl
mat2(vec2, vec2);
mat3(vec3, vec3, vec3);
mat4(vec4, vec4, vec4, vec4);

mat2(float, float,
     float, float);

mat3(float, float, float,
     float, float, float,
     float, float, float);

mat4(float, float, float, float,
     float, float, float, float,
     float, float, float, float,
     float, float, float, float);
```

只要提供足够的分量来初始化矩阵，还有许多其他可能性。但是，目前保留从其他矩阵构造矩阵供将来使用。

### 结构体构造函数

一旦定义了结构体并为其类型指定了名称，就可以使用相同的名称来构造该结构体的实例。例如：

``` glsl
struct light {
  float intensity;
  vec3 position;
};

light lightVar = light(3.0, vec3(1.0, 2.0, 3.0));
```

构造函数的参数必须与声明结构体时的顺序和类型相同。

结构体构造函数可用作初始化器或表达式。

## 向量分量

向量分量的名称用单个字母表示。为了表示方便，根据位置、颜色或纹理坐标向量的常见用法，每个分量都与多个字母相关联。可以在变量名后面加上句点（.）和分量名来选择向量的各个分量。

支持的分量名称有：

|              |                                |
| ------------ | ------------------------------ |
| {x, y, z, w} | 访问表示点或法线的向量时很有用 |
| {r, g, b, a} | 访问表示颜色的向量时很有用     |
| {s, t, p, q} | 访问表示纹理坐标的向量时很有用 |

例如，分量名称 x、r 和 s 是向量中同一（第一）分量的同义词。

请注意，纹理的第三个分量在 OpenGL 中为 r，已重命名为 p，以避免与颜色中的 r（红色）混淆。

访问超出为向量类型声明的分量是错误的，例如：

``` glsl
vec2 pos;
pos.x   // 合法
pos.z   // 非法
```

分量选择语法允许通过在句点（.）后面附加它们的名称（来自同一名称集）来选择多个分量。

``` glsl
vec4 v4;
v4.rgba;    // 是一个 vec4，与直接使用 v4 相同，
v4.rgb;     // 是一个 vec3，
v4.b;       // 是一个浮点数，
v4.xy;      // 是一个 vec2，
v4.xgba;    // 非法 - 分量名称不来自同一集合。
```

分量的顺序可以不同，以对它们进行重组，或复制：

``` glsl
vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);
vec4 swiz = pos.wzyx; // swiz = (4.0, 3.0, 2.0, 1.0)
vec4 dup = pos.xxyy; // dup = (1.0, 1.0, 2.0, 2.0)
```

这种表示法比构造函数语法更简洁。要形成右值，可以将其应用于任何产生向量右值的表达式。

分量组表示法可以出现在表达式的左侧。

``` glsl
vec4 pos = vec4(1.0, 2.0, 3.0, 4.0);
pos.xw = vec2(5.0, 6.0);        // pos = (5.0, 2.0, 3.0, 6.0)
pos.wx = vec2(7.0, 8.0);        // pos = (8.0, 2.0, 3.0, 7.0)
pos.xx = vec2(3.0, 4.0);        // 非法 - 'x' 使用了两次
pos.xy = vec3(1.0, 2.0, 3.0);   // 非法 - vec2 和 vec3 不匹配
```

要形成左值，重组必须应用于向量类型的左值，不包含重复的分量，并根据指定的分量数量生成标量或向量类型的左值。

数组下标语法也可以应用于向量以提供数字索引。因此，在

``` glsl
vec4 pos;
```

中，*pos[2]* 表示 pos 的第三个元素，等价于 *pos.z*。这允许对向量进行变量索引，以及访问分量的通用方式。任何整数表达式都可以用作下标。第一个分量的索引为零。如果索引大于或等于向量的大小，行为是未定义的。

## 矩阵分量

可以使用数组下标语法访问矩阵的分量。对矩阵应用单个下标会将矩阵视为列向量的数组，并选择单个列，其类型是与矩阵大小相同的向量。最左边的列是第 0 列。第二个下标将在列向量上操作，如前面为向量定义的那样。因此，两个下标选择一个列，然后选择一个行。

``` glsl
mat4 m;
m[1] = vec4(2.0);   // 将第二列设置为全部为 2.0
m[0][0] = 1.0;      // 将左上角元素设置为 1.0
m[2][3] = 2.0;      // 将第三列的第 4 个元素设置为 2.0
```

访问矩阵边界之外的分量时（例如 mat3 的 \[3\]\[3\] 分量），行为是未定义的。

## 结构体和字段

与向量分量和重组一样，结构体的字段也使用句点（.）选择。

总之，允许以下运算符操作结构体：

|                  |       |
| ---------------- | ----- |
| 结构体字段选择器 | .     |
| 相等             | == != |
| 赋值             | =     |

相等运算符和赋值运算符仅在两个操作数的类型是相同的声明结构体时才有效。使用相等运算符时，当且仅当所有字段在分量上相等时，两个结构体才相等。

## 赋值

使用赋值运算符（`=`）将值赋给变量名，如

``` glsl
lvalue = expression
```

赋值运算符将表达式的值存储到左值中。只有当表达式和左值具有相同类型时，它才会编译。所有所需的类型转换都必须通过构造函数显式指定。左值必须是可写的。内置类型的变量、整个结构体、结构体字段、应用字段选择器（`.`）选择分量或不重复字段的重组的左值，以及使用数组下标运算符（`[]`）取消引用的左值都是左值。其他二元或一元表达式、非取消引用的数组、函数名、具有重复字段的重组和常量不能是左值。

三元运算符（`?:`）也不允许作为左值。

赋值左侧的表达式在赋值右侧的表达式之前求值。

其他赋值运算符是：

- 算术赋值：加等于（`+=`）、减等于（`-=`）、乘等于（`*=`）和除等于（`/=`）。表达式

  ``` glsl
  lvalue op= expression
  ```

  等价于

  ``` glsl
  lvalue = lvalue op expression
  ```

  并且左值和表达式必须满足 op 和等号（`=`）两者的语义要求。

- 赋值：模等于（`%=`）、左移等于（`<<=`）、右移等于（`>>=`）、按位或等于（`|=`）和按位异或等于（`^=`）。这些运算符是为将来使用而保留的。

在写入（或初始化）变量之前读取它是合法的，但是值是未定义的。

## 表达式

着色语言中的表达式由以下内容构建：

- 类型为 `bool`、`int`、`float`、所有向量类型和所有矩阵类型的常量。
- 所有类型的构造函数。
- 所有类型的变量名，但不包括未跟下标的数组名。
- 带下标的数组名。
- 返回值的函数调用。
- 分量字段选择器和数组下标结果。
- 括号表达式。括号可用于分组操作。括号内的操作在括号之间的操作之前完成。
- 算术二元运算符加（`+`）、减（`-`）、乘（`*`）和除（`/`），对整数和浮点类型的表达式（包括向量和矩阵）进行操作。两个操作数必须是相同的类型，或者一个可以是标量浮点数，另一个是浮点向量或矩阵，或者一个可以是标量整数，另一个是整数向量。此外，对于乘（`*`），一个可以是向量，另一个是具有与向量相同维度大小的矩阵。这些运算的结果与它们操作的表达式具有相同的基本类型（整数或浮点数）。如果一个操作数是标量，另一个是向量或矩阵，则标量分量式地应用于向量或矩阵，结果类型与向量或矩阵相同。除以零不会引发异常，但会产生未指定的值。应用于两个向量的乘（`*`）会产生分量式乘法。应用于两个矩阵的乘（`*`）会产生线性代数矩阵乘法，而不是分量式乘法。使用内置函数 dot、cross 和 matrixCompMult 分别获取向量点积、向量叉积和矩阵分量式乘法。
- 模运算符（`%`）是为将来使用而保留的。
- 算术一元运算符取负（`-`）、后缀和前缀递增和递减（`--` 和 `++`），对整数或浮点值（包括向量和矩阵）进行操作。这些运算的结果与它们操作的类型相同。对于后缀和前缀递增和递减，表达式必须是可以赋值的（`左值`）。前缀递增和前缀递减将 1 或 1.0 加到或减去它们操作的表达式的内容，前缀递增或前缀递减表达式的值是该修改的结果值。后缀递增和后缀递减表达式将 1 或 1.0 加到或减去它们操作的表达式的内容，但结果表达式的值是执行后缀递增或后缀递减之前表达式的值。
- 关系运算符大于（`>`）、小于（`<`）、大于等于（`>=`）和小于等于（`<=`）仅对标量整数和标量浮点表达式进行操作。结果是标量布尔值。操作数的类型必须匹配。要对向量进行分量式比较，请使用内置函数 lessThan、lessThanEqual、greaterThan 和 greaterThanEqual。
- 相等运算符等于（`==`）和不等于（`!=`）对除数组之外的所有类型进行操作。它们的结果是标量布尔值。对于向量、矩阵和结构体，操作数的所有分量必须相等，才能认为操作数相等。要获取向量的分量式相等结果，请使用内置函数 equal 和 notEqual。
- 逻辑二元运算符与（`&&`）、或（`||`）和异或（`^^`）。它们仅对两个布尔表达式进行操作，结果是布尔表达式。与（`&&`）只有在左侧操作数的计算结果为真时才会计算右侧操作数。或（`||`）只有在左侧操作数的计算结果为假时才会计算右侧操作数。异或（`^^`）总是计算两个操作数。
- 逻辑一元运算符非（`!`）。它只对布尔表达式进行操作，结果是布尔表达式。要对向量进行操作，请使用内置函数 not。
- 序列（`,`）运算符通过返回逗号分隔的表达式列表中最右边表达式的类型和值来对表达式进行操作。所有表达式都按从左到右的顺序求值。
- 三元选择运算符（`?:`）。它对三个表达式进行操作（`exp1 ? exp2 : exp3`）。该运算符计算第一个表达式，其结果必须是标量布尔值。如果结果为真，则选择计算第二个表达式，否则选择计算第三个表达式。只有第二个和第三个表达式中的一个会被计算。第二个和第三个表达式必须是相同的类型，但可以是除数组之外的任何类型。结果类型与第二个和第三个表达式的类型相同。
- 运算符与（`&`）、或（`|`）、异或（`^`）、非（`~`）、右移（`>>`）、左移（`<<`）。这些运算符是为将来使用而保留的。

有关表达式语法的完整规范，请参见第 9 节“着色语言语法”。

当操作数类型不同时，它们必须符合以下规则之一：

- 其中一个参数是浮点数（即标量），在这种情况下，结果就好像在应用之前将标量值复制到向量或矩阵中。
- 左侧参数是浮点向量，右侧是具有兼容维度的矩阵，在这种情况下，`*` 运算符将执行行向量矩阵乘法。
- 左侧参数是矩阵，右侧是具有兼容维度的浮点向量，在这种情况下，`*` 运算符将执行列向量矩阵乘法。

## 向量和矩阵运算

除少数例外，运算都是分量式的。当运算符对向量或矩阵进行操作时，它是以分量式方式独立地对向量或矩阵的每个分量进行操作。

例如，

``` glsl
vec3 v, u;
float f;
v = u + f;
```

将等价于

``` glsl
v.x = u.x + f;
v.y = u.y + f;
v.z = u.z + f;
```

并且

``` glsl
vec3 v, u, w;
w = v + u;
```

将等价于

``` glsl
w.x = v.x + u.x;
w.y = v.y + u.y;
w.z = v.z + u.z;
```

对于大多数运算符以及所有整数和浮点向量和矩阵类型也是如此。例外情况是矩阵乘以向量、向量乘以矩阵以及矩阵乘以矩阵。这些不是分量式操作，而是执行正确的线性代数乘法。它们要求操作数的大小匹配。

``` glsl
vec3 v, u;
mat3 m;

u = v * m;
```

等价于

``` glsl
u.x = dot(v, m[0]); // m[0] 是 m 的左列
u.y = dot(v, m[1]); // dot(a,b) 是 a 和 b 的内积（点积）
u.z = dot(v, m[2]);
```

并且

``` glsl
u = m * v;
```

等价于

``` glsl
u.x = m[0].x * v.x + m[1].x * v.y + m[2].x * v.z;
u.y = m[0].y * v.x + m[1].y * v.y + m[2].y * v.z;
u.z = m[0].z * v.x + m[1].z * v.y + m[2].z * v.z;
```

并且

``` glsl
mat m, n, r;

r = m * n;
```

等价于

``` glsl
r[0].x = m[0].x * n[0].x + m[1].x * n[0].y + m[2].x * n[0].z;
r[1].x = m[0].x * n[1].x + m[1].x * n[1].y + m[2].x * n[1].z;
r[2].x = m[0].x * n[2].x + m[1].x * n[2].y + m[2].x * n[2].z;


r[0].y = m[0].y * n[0].x + m[1].y * n[0].y + m[2].y * n[0].z;
r[1].y = m[0].y * n[1].x + m[1].y * n[1].y + m[2].y * n[1].z;
r[2].y = m[0].y * n[2].x + m[1].y * n[2].y + m[2].y * n[2].z;

r[0].z = m[0].z * n[0].x + m[1].z * n[0].y + m[2].z * n[0].z;
r[1].z = m[0].z * n[1].x + m[1].z * n[1].y + m[2].z * n[1].z;
r[2].z = m[0].z * n[2].x + m[1].z * n[2].y + m[2].z * n[2].z;
```

对于大小为 2 和 4 的向量和矩阵也是类似的。

所有一元运算都在其操作数上分量式地工作。对于二元算术运算，如果两个操作数类型相同，则该运算以分量方式完成，并产生与操作数相同类型的结果。如果一个操作数是标量浮点数，另一个操作数是向量或矩阵，则该运算将按照标量值复制形成匹配的向量或矩阵操作数的方式进行。
